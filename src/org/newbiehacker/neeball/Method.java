/*
 * Copyright (c) 2007, James Lawrence
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the <organization> nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package org.newbiehacker.neeball;

import org.newbiehacker.neeball.pool.*;

import java.io.*;
import java.util.*;

/**
 * Copyright 2006 James Lawrence
 * Date: 10-Feb-2007
 * Time: 16:04:37
 * Modification and redistribution without explicit permission by the creator(s) is prohibited
 * This source may be modified for personal use as long as the original author is accredited
 */
public final class Method implements Comparable<Method> {
    /**
     * <p>Declared public; may be accessed from outside its package.</p>
     */
    public static final int ACC_PUBLIC = 0x0001;
    /**
     * <p>Declared private; accessible only within the defining class.</p>
     */
    public static final int ACC_PRIVATE = 0x0002;
    /**
     * <p>Declared protected; may be accessed within subclasses.</p>
     */
    public static final int ACC_PROTECTED = 0x0004;
    /**
     * <p>Declared static.</p>
     */
    public static final int ACC_STATIC = 0x0008;
    /**
     * <p>Declared final; may not be overridden.</p>
     */
    public static final int ACC_FINAL = 0x0010;
    /**
     * <p>Declared synchronized; invocation is wrapped in a monitor lock.</p>
     */
    public static final int ACC_SYNCHRONIZED = 0x0020;
    /**
     * <p>A bridge method, generated by the compiler.</p>
     */
    public static final int ACC_BRIDGE = 0x0040;
    /**
     * <p>Declared with variable number of arguments.</p>
     */
    public static final int ACC_VARARGS = 0x0080;
    /**
     * <p>Declared native; implemented in a language other than Java.</p>
     */
    public static final int ACC_NATIVE = 0x0100;
    /**
     * <p>Declared abstract; no implementation is provided.</p>
     */
    public static final int ACC_ABSTRACT = 0x0400;
    /**
     * <p>Declared strictfp; floating-point mode is FP-strict</p>
     */
    public static final int ACC_STRICT = 0x0800;
    /**
     * <p>Declared synthetic; Not present in the source code.</p>
     */
    public static final int ACC_SYNTHETIC = 0x1000;

    /**
     * <p>Whether this method is public</p>
     */
    public boolean is_public;
    /**
     * <p>Whether this method is private</p>
     */
    public boolean is_private;
    /**
     * <p>Whether this method is protected</p>
     */
    public boolean is_protected;
    /**
     * <p>Whether this method is static</p>
     */
    public boolean is_static;
    /**
     * <p>Whether this method is final</p>
     */
    public boolean is_final;
    /**
     * <p>Whether this method is synchronized</p>
     */
    public boolean is_synchronized;
    /**
     * <p>Whether this method is a bridge method that was generated by the compiler</p>
     */
    public boolean is_bridge;
    /**
     * <p>Whether this method uses varaargs in parameters</p>
     */
    public boolean has_varargs;
    /**
     * <p>Whether this method is native</p>
     */
    public boolean is_native;
    /**
     * <p>Whether this method is abstract</p>
     */
    public boolean is_abstract;
    /**
     * <p>Whether this method is fpstrict</p>
     */
    public boolean is_strict;
    /**
     * <p>Whether this method is synthetic</p>
     */
    public boolean is_synthetic;

    /**
     * <p>Whether this method has a deprecated attribute</p>
     */
    public boolean deprecated;
    /**
     * <p>Whether this method has a synthetic attribute</p>
     */
    public boolean synthetic;
    /**
     * <p>The name of this method</p>
     */
    public String name;
    int name_index;
    /**
     * <p>The descriptor of this method</p>
     */
    public String descriptor;
    int descriptor_index;
    // Flattened from Code attribute
    /**
     * <p>The size to be allocated to the stack (used internally)</p>
     * <p><b>Todo</b>: calculate internally</p>
     */
    public int max_stack;
    /**
     * <p>This should be null if this method is abstract, if not it contains the code for this method</p>
     */
    public List<Instruction> code;
    /**
     * <p>This should be null if this method is abstract if not it contains a list of <code>ExceptionTableEntry</code>s which tell the JVM how to handle exceptions</p>
     *
     * @see ExceptionTableEntry
     */
    public List<ExceptionTableEntry> exception_table;
    // Flattened from Exceptions attribute
    /**
     * <p>The exceptions that this method throws (or null if none)</p>
     */
    public List<String> thrown_exceptions_table;
    int[] exception_index_table;
    // Flattened from Signature attribute
    /**
     * <p>The signature attribute of this method</p>
     */
    public String signature;
    int signature_index;

    /**
     * <p>Constructs a new <code>Method</code> with every field set</p>
     *
     * @param name         the name of this method
     * @param descriptor   the descriptor of this method
     * @param access_flags the access flags of this method
     * @param deprecated   whether this method is deprecated
     * @param synthetic    whether this method is synthetic
     */
    public Method(String name, String descriptor, int access_flags, boolean deprecated, boolean synthetic) {
        this.name = name;
        this.descriptor = descriptor;
        is_public = (access_flags & ACC_PUBLIC) != 0;
        is_private = (access_flags & ACC_PRIVATE) != 0;
        is_protected = (access_flags & ACC_PROTECTED) != 0;
        is_static = (access_flags & ACC_STATIC) != 0;
        is_final = (access_flags & ACC_FINAL) != 0;
        is_synchronized = (access_flags & ACC_SYNCHRONIZED) != 0;
        is_bridge = (access_flags & ACC_BRIDGE) != 0;
        has_varargs = (access_flags & ACC_VARARGS) != 0;
        is_native = (access_flags & ACC_NATIVE) != 0;
        is_abstract = (access_flags & ACC_ABSTRACT) != 0;
        is_strict = (access_flags & ACC_STRICT) != 0;
        is_synthetic = (access_flags & ACC_SYNTHETIC) != 0;
        this.deprecated = deprecated;
        this.synthetic = synthetic;
        if(!is_abstract && !is_native) {
            this.code = new ArrayList<>();
            this.exception_table = new LinkedList<>();
        }
    }

    /**
     * <p>Constructs a new <code>Method</code> with the specified name, descriptor and access flags</p>
     *
     * @param name         this methods name
     * @param descriptor   this methods descriptor
     * @param access_flags this methods access flags
     */
    public Method(String name, String descriptor, int access_flags) {
        this(name, descriptor, access_flags, false, false);
    }

    /**
     * <p>Constructs a new <code>Method</code> with the specified name and descriptor</p>
     *
     * @param name       the name of this method
     * @param descriptor the descriptor of this method
     */
    public Method(String name, String descriptor) {
        this(name, descriptor, 0, false, false);
    }

    /**
     * <p>Constructs a new <code>Method</code> with no set values</p>
     */
    public Method() {
    }

    private static int getPadding(int index) {
        ++index;
        final int i = 4 - index % 4;
        if (i == 4)
            return 0;
        return i;
    }

    void setBytes(byte[] b, ConstantPool cp) throws IOException {
        DataInputStream dis = new DataInputStream(new ByteArrayInputStream(b));
        while (dis.available() > 0) {
            int o = dis.readUnsignedByte();
            if (o == 0x32) {
                code.add(new AALOAD());
            } else if (o == 0x53) {
                code.add(new AASTORE());
            } else if (o == 0x1) {
                code.add(new ACONST_NULL());
            } else if (o == 0x19) {
                code.add(new ALOAD(dis.readUnsignedByte()));
            } else if (o == 0x2a) {
                code.add(new ALOAD(0));
            } else if (o == 0X2b) {
                code.add(new ALOAD(1));
            } else if (o == 0x2c) {
                code.add(new ALOAD(2));
            } else if (o == 0x2d) {
                code.add(new ALOAD(3));
            } else if (o == 0xbd) {
                code.add(new ANEWARRAY(((ConstantClass) cp.get(dis.readUnsignedShort())).value));
            } else if (o == 0xb0) {
                code.add(new ARETURN());
            } else if (o == 0xbe) {
                code.add(new ARRAYLENGTH());
            } else if (o == 0x3a) {
                code.add(new ASTORE(dis.readUnsignedByte()));
            } else if (o == 0x4b) {
                code.add(new ASTORE(0));
            } else if (o == 0x4c) {
                code.add(new ASTORE(1));
            } else if (o == 0x4d) {
                code.add(new ASTORE(2));
            } else if (o == 0x4e) {
                code.add(new ASTORE(3));
            } else if (o == 0xbf) {
                code.add(new ATHROW());
            } else if (o == 0x33) {
                code.add(new BALOAD());
            } else if (o == 0x54) {
                code.add(new BASTORE());
            } else if (o == 0x10) {
                code.add(new BIPUSH(dis.readByte()));
            } else if (o == 0x34) {
                code.add(new CALOAD());
            } else if (o == 0x55) {
                code.add(new CASTORE());
            } else if (o == 0xc0) {
                code.add(new CHECKCAST(((ConstantClass) cp.get(dis.readUnsignedShort())).value));
            } else if (o == 0x90) {
                code.add(new D2F());
            } else if (o == 0x8e) {
                code.add(new D2I());
            } else if (o == 0x8f) {
                code.add(new D2L());
            } else if (o == 0x63) {
                code.add(new DADD());
            } else if (o == 0x31) {
                code.add(new DALOAD());
            } else if (o == 0x52) {
                code.add(new DASTORE());
            } else if (o == 0x98) {
                code.add(new DCMPG());
            } else if (o == 0x97) {
                code.add(new DCMPL());
            } else if (o == 0xe) {
                code.add(new DCONST_0());
            } else if (o == 0xf) {
                code.add(new DCONST_1());
            } else if (o == 0x6f) {
                code.add(new DDIV());
            } else if (o == 0x18) {
                code.add(new DLOAD(dis.readUnsignedByte()));
            } else if (o == 0x26) {
                code.add(new DLOAD(0));
            } else if (o == 0x27) {
                code.add(new DLOAD(1));
            } else if (o == 0x28) {
                code.add(new DLOAD(2));
            } else if (o == 0x29) {
                code.add(new DLOAD(3));
            } else if (o == 0x6b) {
                code.add(new DMUL());
            } else if (o == 0x77) {
                code.add(new DNEG());
            } else if (o == 0x73) {
                code.add(new DREM());
            } else if (o == 0xaf) {
                code.add(new DRETURN());
            } else if (o == 0x39) {
                code.add(new DSTORE(dis.readUnsignedByte()));
            } else if (o == 0x47) {
                code.add(new DSTORE(0));
            } else if (o == 0x48) {
                code.add(new DSTORE(1));
            } else if (o == 0x49) {
                code.add(new DSTORE(2));
            } else if (o == 0x4a) {
                code.add(new DSTORE(3));
            } else if (o == 0x67) {
                code.add(new DSUB());
            } else if (o == 0x59) {
                code.add(new DUP());
            } else if (o == 0x5a) {
                code.add(new DUP_X1());
            } else if (o == 0x5b) {
                code.add(new DUP_X2());
            } else if (o == 0x5c) {
                code.add(new DUP2());
            } else if (o == 0x5d) {
                code.add(new DUP2_X1());
            } else if (o == 0x5e) {
                code.add(new DUP2_X2());
            } else if (o == 0x8d) {
                code.add(new F2D());
            } else if (o == 0x8b) {
                code.add(new F2I());
            } else if (o == 0x8c) {
                code.add(new F2L());
            } else if (o == 0x62) {
                code.add(new FADD());
            } else if (o == 0x30) {
                code.add(new FALOAD());
            } else if (o == 0x51) {
                code.add(new FASTORE());
            } else if (o == 0x96) {
                code.add(new FCMPG());
            } else if (o == 0x95) {
                code.add(new FCMPL());
            } else if (o == 0xb) {
                code.add(new FCONST_0());
            } else if (o == 0xc) {
                code.add(new FCONST_1());
            } else if (o == 0xd) {
                code.add(new FCONST_2());
            } else if (o == 0x6e) {
                code.add(new FDIV());
            } else if (o == 0x17) {
                code.add(new FLOAD(dis.readUnsignedByte()));
            } else if (o == 0x22) {
                code.add(new FLOAD(0));
            } else if (o == 0x23) {
                code.add(new FLOAD(1));
            } else if (o == 0x24) {
                code.add(new FLOAD(2));
            } else if (o == 0x25) {
                code.add(new FLOAD(3));
            } else if (o == 0x6a) {
                code.add(new FMUL());
            } else if (o == 0x76) {
                code.add(new FNEG());
            } else if (o == 0x72) {
                code.add(new FREM());
            } else if (o == 0xae) {
                code.add(new FRETURN());
            } else if (o == 0x38) {
                code.add(new FSTORE(dis.readUnsignedByte()));
            } else if (o == 0x43) {
                code.add(new FSTORE(0));
            } else if (o == 0x44) {
                code.add(new FSTORE(1));
            } else if (o == 0x45) {
                code.add(new FSTORE(2));
            } else if (o == 0x46) {
                code.add(new FSTORE(3));
            } else if (o == 0x66) {
                code.add(new FSUB());
            } else if (o == 0xb4) {
                code.add(new GETFIELD((ConstantFieldref) cp.get(dis.readUnsignedShort())));
            } else if (o == 0xb2) {
                code.add(new GETSTATIC((ConstantFieldref) cp.get(dis.readUnsignedShort())));
            } else if (o == 0xa7) {
                GOTO g = new GOTO();
                g.branchoffset = dis.readShort();
                code.add(g);
            } else if (o == 0xc8) {
                GOTO g = new GOTO();
                g.branchoffset = dis.readInt();
                code.add(g);
            } else if (o == 0x91) {
                code.add(new I2B());
            } else if (o == 0x92) {
                code.add(new I2C());
            } else if (o == 0x87) {
                code.add(new I2D());
            } else if (o == 0x86) {
                code.add(new I2F());
            } else if (o == 0x85) {
                code.add(new I2L());
            } else if (o == 0x93) {
                code.add(new I2S());
            } else if (o == 0x60) {
                code.add(new IADD());
            } else if (o == 0x2e) {
                code.add(new IALOAD());
            } else if (o == 0x7e) {
                code.add(new IAND());
            } else if (o == 0x4f) {
                code.add(new IASTORE());
            } else if (o == 0x2) {
                code.add(new ICONST_M1());
            } else if (o == 0x3) {
                code.add(new ICONST_0());
            } else if (o == 0x4) {
                code.add(new ICONST_1());
            } else if (o == 0x5) {
                code.add(new ICONST_2());
            } else if (o == 0x6) {
                code.add(new ICONST_3());
            } else if (o == 0x7) {
                code.add(new ICONST_4());
            } else if (o == 0x8) {
                code.add(new ICONST_5());
            } else if (o == 0x6c) {
                code.add(new IDIV());
            } else if (o == 0xa5) {
                IF_ACMPEQ i = new IF_ACMPEQ();
                i.branchoffset = dis.readShort();
                code.add(i);
            } else if (o == 0xa6) {
                IF_ACMPNE i = new IF_ACMPNE();
                i.branchoffset = dis.readShort();
                code.add(i);
            } else if (o == 0x9f) {
                IF_ICMPEQ i = new IF_ICMPEQ();
                i.branchoffset = dis.readShort();
                code.add(i);
            } else if (o == 0xa0) {
                IF_ICMPNE i = new IF_ICMPNE();
                i.branchoffset = dis.readShort();
                code.add(i);
            } else if (o == 0xa1) {
                IF_ICMPLT i = new IF_ICMPLT();
                i.branchoffset = dis.readShort();
                code.add(i);
            } else if (o == 0xa2) {
                IF_ICMPGE i = new IF_ICMPGE();
                i.branchoffset = dis.readShort();
                code.add(i);
            } else if (o == 0xa3) {
                IF_ICMPGT i = new IF_ICMPGT();
                i.branchoffset = dis.readShort();
                code.add(i);
            } else if (o == 0xa4) {
                IF_ICMPLE i = new IF_ICMPLE();
                i.branchoffset = dis.readShort();
                code.add(i);
            } else if (o == 0x99) {
                IFEQ i = new IFEQ();
                i.branchoffset = dis.readShort();
                code.add(i);
            } else if (o == 0x9a) {
                IFNE i = new IFNE();
                i.branchoffset = dis.readShort();
                code.add(i);
            } else if (o == 0x9b) {
                IFLT i = new IFLT();
                i.branchoffset = dis.readShort();
                code.add(i);
            } else if (o == 0x9c) {
                IFGE i = new IFGE();
                i.branchoffset = dis.readShort();
                code.add(i);
            } else if (o == 0x9d) {
                IFGT i = new IFGT();
                i.branchoffset = dis.readShort();
                code.add(i);
            } else if (o == 0x9e) {
                IFLE i = new IFLE();
                i.branchoffset = dis.readShort();
                code.add(i);
            } else if (o == 0xc7) {
                IFNONNULL i = new IFNONNULL();
                i.branchoffset = dis.readShort();
                code.add(i);
            } else if (o == 0xc6) {
                IFNULL i = new IFNULL();
                i.branchoffset = dis.readShort();
                code.add(i);
            } else if (o == 0x84) {
                code.add(new IINC(dis.readUnsignedByte(), dis.readByte()));
            } else if (o == 0x15) {
                code.add(new ILOAD(dis.readUnsignedByte()));
            } else if (o == 0x1a) {
                code.add(new ILOAD(0));
            } else if (o == 0x1b) {
                code.add(new ILOAD(1));
            } else if (o == 0x1c) {
                code.add(new ILOAD(2));
            } else if (o == 0x1d) {
                code.add(new ILOAD(3));
            } else if (o == 0x68) {
                code.add(new IMUL());
            } else if (o == 0x74) {
                code.add(new INEG());
            } else if (o == 0xc1) {
                code.add(new INSTANCEOF(((ConstantClass) cp.get(dis.readUnsignedShort())).value));
            } else if (o == 0xb9) {
                code.add(new INVOKEINTERFACE((ConstantInterfaceMethodref) cp.get(dis.readUnsignedShort())));
                dis.readUnsignedByte(); // Read parameter count
                dis.readByte(); // ConstantValue 0, used internally
            } else if (o == 0xb7) {
                code.add(new INVOKESPECIAL((ConstantMethodref) cp.get(dis.readUnsignedShort())));
            } else if (o == 0xb8) {
                code.add(new INVOKESTATIC((ConstantMethodref) cp.get(dis.readUnsignedShort())));
            } else if (o == 0xb6) {
                code.add(new INVOKEVIRTUAL((ConstantMethodref) cp.get(dis.readUnsignedShort())));
            } else if (o == 0x80) {
                code.add(new IOR());
            } else if (o == 0x70) {
                code.add(new IREM());
            } else if (o == 0xac) {
                code.add(new IRETURN());
            } else if (o == 0x78) {
                code.add(new ISHL());
            } else if (o == 0x7a) {
                code.add(new ISHR());
            } else if (o == 0x36) {
                code.add(new ISTORE(dis.readUnsignedByte()));
            } else if (o == 0x3b) {
                code.add(new ISTORE(0));
            } else if (o == 0x3c) {
                code.add(new ISTORE(1));
            } else if (o == 0x3d) {
                code.add(new ISTORE(2));
            } else if (o == 0x3e) {
                code.add(new ISTORE(3));
            } else if (o == 0x64) {
                code.add(new ISUB());
            } else if (o == 0x7c) {
                code.add(new IUSHR());
            } else if (o == 0x82) {
                code.add(new IXOR());
            } else if (o == 0xa8) {
                JSR j = new JSR();
                j.branchoffset = dis.readShort();
                code.add(j);
            } else if (o == 0xc9) {
                JSR j = new JSR();
                j.branchoffset = dis.readInt();
                code.add(j);
            } else if (o == 0x8a) {
                code.add(new L2D());
            } else if (o == 0x89) {
                code.add(new L2F());
            } else if (o == 0x88) {
                code.add(new L2I());
            } else if (o == 0x61) {
                code.add(new LADD());
            } else if (o == 0x2f) {
                code.add(new LALOAD());
            } else if (o == 0x7f) {
                code.add(new LAND());
            } else if (o == 0x50) {
                code.add(new LASTORE());
            } else if (o == 0x94) {
                code.add(new LCMP());
            } else if (o == 0x9) {
                code.add(new LCONST_0());
            } else if (o == 0xa) {
                code.add(new LCONST_1());
            } else if (o == 0x12) {
                code.add(new LDC(cp.get(dis.readUnsignedByte())));
            } else if (o == 0x13) {
                code.add(new LDC(cp.get(dis.readUnsignedShort())));
            } else if (o == 0x14) {
                code.add(new LDC(cp.get(dis.readUnsignedShort())));
            } else if (o == 0x6d) {
                code.add(new LDIV());
            } else if (o == 0x16) {
                code.add(new LLOAD(dis.readUnsignedByte()));
            } else if (o == 0x1e) {
                code.add(new LLOAD(0));
            } else if (o == 0x1f) {
                code.add(new LLOAD(1));
            } else if (o == 0x20) {
                code.add(new LLOAD(2));
            } else if (o == 0x21) {
                code.add(new LLOAD(3));
            } else if (o == 0x69) {
                code.add(new LMUL());
            } else if (o == 0x75) {
                code.add(new LNEG());
            } else if (o == 0x81) {
                code.add(new LOR());
            } else if (o == 0xab) {
                int index = getOffset(code.size());
                int padding = getPadding(index);
                for (int i = 0; i < padding; i++)
                    dis.readByte();
                int default_offset = dis.readInt();
                int length = dis.readInt();
                int[] matches = new int[length];
                int[] offsets = new int[length];
                for (int i = 0; i < length; i++) {
                    matches[i] = dis.readInt();
                    offsets[i] = dis.readInt();
                }
                code.add(new LOOKUPSWITCH(default_offset, matches, offsets));
            } else if (o == 0x71) {
                code.add(new LREM());
            } else if (o == 0xad) {
                code.add(new LRETURN());
            } else if (o == 0x79) {
                code.add(new LSHL());
            } else if (o == 0x7b) {
                code.add(new LSHR());
            } else if (o == 0x37) {
                code.add(new LSTORE(dis.readUnsignedByte()));
            } else if (o == 0x3f) {
                code.add(new LSTORE(0));
            } else if (o == 0x40) {
                code.add(new LSTORE(1));
            } else if (o == 0x41) {
                code.add(new LSTORE(2));
            } else if (o == 0x42) {
                code.add(new LSTORE(3));
            } else if (o == 0x65) {
                code.add(new LSUB());
            } else if (o == 0x7d) {
                code.add(new LUSHR());
            } else if (o == 0x83) {
                code.add(new LXOR());
            } else if (o == 0xc2) {
                code.add(new MONITORENTER());
            } else if (o == 0xc3) {
                code.add(new MONITOREXIT());
            } else if (o == 0xc5) {
                code.add(new MULTIANEWARRAY(((ConstantClass) cp.get(dis.readUnsignedShort())).value, dis.readUnsignedByte()));
            } else if (o == 0xbb) {
                code.add(new NEW(((ConstantClass) cp.get(dis.readUnsignedShort())).value));
            } else if (o == 0xbc) {
                code.add(new NEWARRAY(dis.readUnsignedByte()));
            } else if (o == 0x0) {
                code.add(new NOP());
            } else if (o == 0x57) {
                code.add(new POP());
            } else if (o == 0x58) {
                code.add(new POP2());
            } else if (o == 0xb5) {
                code.add(new PUTFIELD((ConstantFieldref) cp.get(dis.readUnsignedShort())));
            } else if (o == 0xb3) {
                code.add(new PUTSTATIC((ConstantFieldref) cp.get(dis.readUnsignedShort())));
            } else if (o == 0xa9) {
                code.add(new RET(dis.readUnsignedByte()));
            } else if (o == 0xb1) {
                code.add(new RETURN());
            } else if (o == 0x35) {
                code.add(new SALOAD());
            } else if (o == 0x56) {
                code.add(new SASTORE());
            } else if (o == 0x11) {
                code.add(new SIPUSH(dis.readShort()));
            } else if (o == 0x5f) {
                code.add(new SWAP());
            } else if (o == 0xaa) {
                int index = getOffset(code.size());
                int padding = getPadding(index);
                for (int i = 0; i < padding; i++)
                    dis.readByte();
                int default_offset = dis.readInt();
                int low = dis.readInt();
                int high = dis.readInt();
                int length = high - low + 1;
                int[] matches = new int[length];
                int[] offsets = new int[length];
                for (int i = low; i <= high; i++)
                    matches[i - low] = i;
                for (int i = 0; i < length; i++)
                    offsets[i] = dis.readInt();
                code.add(new TABLESWITCH(default_offset, matches, offsets));
            } else if (o == 0xc4) {
                code.add(readWideInstruction(dis));
            } else {
                StringBuilder sb = new StringBuilder("Unknown Instruction: ").append(Integer.toHexString(o)).append("\nCode dump:\n");
                for (int i = 0; i < code.size(); i++) {
                    sb.append(i).append("\t").append(code.get(i)).append("\n");
                }
                throw new IOException(sb.toString());
            }
        }
        dis.close();
    }

    private Instruction readWideInstruction(DataInputStream dis) throws IOException {
        int o = dis.readUnsignedByte();
        if (o == 0x19) {
            return new ALOAD(dis.readUnsignedShort(), true);
        } else if (o == 0x3a) {
            return new ASTORE(dis.readUnsignedShort(), true);
        } else if (o == 0x18) {
            return new DLOAD(dis.readUnsignedShort(), true);
        } else if (o == 0x39) {
            return new DSTORE(dis.readUnsignedShort(), true);
        } else if (o == 0x17) {
            return new FLOAD(dis.readUnsignedShort(), true);
        } else if (o == 0x38) {
            return new FSTORE(dis.readUnsignedShort(), true);
        } else if (o == 0x15) {
            return new ILOAD(dis.readUnsignedShort(), true);
        } else if (o == 0x36) {
            return new ISTORE(dis.readUnsignedShort(), true);
        } else if (o == 0x16) {
            return new LLOAD(dis.readUnsignedShort(), true);
        } else if (o == 0x37) {
            return new LSTORE(dis.readUnsignedShort(), true);
        } else if (o == 0xa9) {
            return new RET(dis.readUnsignedShort(), true);
        } else if (o == 0x84) {
            return new IINC(dis.readUnsignedShort(), dis.readShort(), true);
        } else
            throw new IOException("Unknown instruction after wide: " + Integer.toHexString(o));
    }

    int getIndex(int offset) {
        int t = 0;
        int index = 0;
        Instruction i;
        while (t < offset) {
            i = code.get(index++);
            //System.out.println(i);
            if (i instanceof Switch)
                t += getPadding(t);
            t += i.getLength();
        }
        return index;
    }

    void setIndices() {
        Instruction i;
        BranchInstruction ci;
        Switch s;
        Iterator<Integer> it;
        int i1;
        Integer in;
        final int codeSize = code.size();
        int length;
        for (int idx = 0; idx < codeSize; idx++) {
            i = code.get(idx);
            if (i instanceof BranchInstruction) {
                ci = (BranchInstruction) i;
                ci.branch_index = getIndex(getOffset(idx) + ci.branchoffset);
                if (i instanceof Switch) {
                    s = (Switch) i;
                    it = s.match_pair_offsets.keySet().iterator();
                    length = s.match_pair_offsets.size();
                    for (i1 = 0; i1 < length; i1++) {
                        in = it.next();
                        s.match_pairs.put(in, getIndex(getOffset(idx) + s.match_pair_offsets.get(in)));
                    }
                }
            }
        }
        for (ExceptionTableEntry ete : exception_table) {
            ete.start_index = getIndex(ete.start_pc);
            ete.end_index = getIndex(ete.end_pc);
            ete.handler_index = getIndex(ete.handler_pc);
        }
    }

    int getOffset(int index) {
        int offset = 0;
        Instruction ins;
        for (int i = 0; i < index; i++) {
            ins = code.get(i);
            if (ins instanceof Switch)
                offset += getPadding(offset);
            offset += ins.getLength();
        }
        return offset;
    }

    void resetOffsets() {
        Instruction i;
        BranchInstruction ci;
        Switch s;
        int off;
        for (int idx = 0; idx < code.size(); idx++) {
            i = code.get(idx);
            if (i instanceof BranchInstruction) {
                off = getOffset(idx);
                ci = (BranchInstruction) i;
                ci.branchoffset = getOffset(ci.branch_index) - off;
                if (i instanceof Switch) {
                    s = (Switch) i;
                    s.match_pair_offsets.clear();
                    for (final Integer in : s.match_pairs.keySet()) {
                        s.match_pair_offsets.put(in, getOffset(s.match_pairs.get(in)) - off);
                    }
                }
            }
        }
        for (ExceptionTableEntry ete : exception_table) {
            ete.start_pc = getOffset(ete.start_index);
            ete.end_pc = getOffset(ete.end_index);
            ete.handler_pc = getOffset(ete.handler_index);
        }
    }

    private void fix() {
        main:
        for (int idx = 0; idx < code.size(); idx++) {
            Instruction i = code.get(idx);
            if (i instanceof LOOKUPSWITCH) {
                LOOKUPSWITCH lus = (LOOKUPSWITCH) i;
                Iterator<Integer> keys = lus.match_pairs.navigableKeySet().iterator();
                if (!keys.hasNext()) {
                    TABLESWITCH ts = new TABLESWITCH(lus.branch_index, new ArrayList<Integer>(), new ArrayList<Integer>());
                    replaceInstruction(idx, ts);
                    resetOffsets();
                }
                int lastKey = keys.next();
                int key;
                while (keys.hasNext()) {
                    key = keys.next();
                    if (key != lastKey + 1)
                        continue main;
                    lastKey = key;
                }
                keys = lus.match_pairs.descendingKeySet().iterator();
                ArrayList<Integer> matches = new ArrayList<>();
                ArrayList<Integer> indices = new ArrayList<>();
                while (keys.hasNext()) {
                    key = keys.next();
                    matches.add(key);
                    indices.add(lus.match_pairs.get(key));
                }
                TABLESWITCH ts = new TABLESWITCH(lus.branch_index, matches, indices);
                replaceInstruction(idx, ts);
                resetOffsets();
                idx = 0;
            } else if (i instanceof TABLESWITCH) {
                TABLESWITCH ts = (TABLESWITCH) i;
                Iterator<Integer> keys = ts.match_pairs.navigableKeySet().iterator();
                if (!keys.hasNext())
                    continue;
                int lastKey = keys.next();
                int key;
                while (keys.hasNext()) {
                    key = keys.next();
                    if (key != lastKey + 1) {
                        ArrayList<Integer> matches = new ArrayList<>();
                        ArrayList<Integer> indices = new ArrayList<>();
                        matches.addAll(ts.match_pairs.keySet());
                        indices.addAll(ts.match_pairs.values());
                        LOOKUPSWITCH lus = new LOOKUPSWITCH(ts.branch_index, matches, indices);
                        replaceInstruction(idx, lus);
                        resetOffsets();
                        idx = 0;
                        continue main;
                    }
                    lastKey = key;
                }
            }
        }
    }

    /**
     * <p>Inserts an instruction at the specified index</p>
     *
     * @param index       the index into the <code>code List</code> on where to insert this instruction
     * @param instruction the instruction to insert
     */
    public void insertInstruction(int index, Instruction instruction) {
        code.add(index, instruction);
        for (Instruction in : code) {
            if (in instanceof BranchInstruction) {
                BranchInstruction bi = (BranchInstruction) in;
                if (bi.branch_index >= index)
                    bi.branch_index += 1;
            } else if (in instanceof Switch) {
                Switch s = (Switch) in;
                if (s.branch_index >= index)
                    s.branch_index += 1;
                Integer i = null;
                for (Iterator<Integer> it = s.match_pairs.keySet().iterator(); it.hasNext(); i = it.next())
                    if (s.match_pairs.get(i) >= index)
                        s.match_pairs.put(i, s.match_pairs.get(i) + 1);
            }
        }
    }

    /**
     * <p>Replaces the instruction at the specified index with a new instruction</p>
     *
     * @param index           the index into the <code>code List</code> on where to replace the old instruction with the new one
     * @param new_instruction the instruction to replace the old one with
     */
    public void replaceInstruction(int index, Instruction new_instruction) {
        code.set(index, new_instruction);
    }

    /**
     * <p>Removes the instruction at the specified index</p>
     *
     * @param index the index into the <code>code List</code> on where to insert this instruction
     */
    public void removeInstruction(int index) {
        code.remove(index);
        for (Instruction i : code) {
            if (i instanceof BranchInstruction) {
                BranchInstruction bi = (BranchInstruction) i;
                if (bi.branch_index > index)
                    bi.branch_index -= 1;
            } else if (i instanceof Switch) {
                Switch s = (Switch) i;
                if (s.branch_index >= index)
                    s.branch_index += 1;
                Integer in = null;
                for (Iterator<Integer> it = s.match_pairs.keySet().iterator(); it.hasNext(); in = it.next())
                    if (s.match_pairs.get(in) > index)
                        s.match_pairs.put(in, s.match_pairs.get(in) + -1);
            }
        }
    }

    /**
     * <p>Searches through this methods code for a specified pattern, pattern syntax is explained below</p>
     * <p>Patterns are strings with special characters which define special properties</p>
     * <p>For example, you may have a pattern like "ALOAD IFNULL GETFIELD RETURN" which is very simple, but not very versatile.</p>
     * <p>That's where some simple logic checking comes in, by enclosing instructions in brackets and putting '|' chars between them you can have embedded 'IF' logic in your pattern</p>
     * <p>For example "ALOAD (IFNULL | IFNONNULL) (GETFIELD | GETSTATIC)" is a much more versatile pattern (note that these are only examples</p>
     * <p>You can also have nested if-expressions like "INS (INS | (INS | INS (INS | INS)))"</p>
     * <p><b>NOTE:</b> I noticed some limitations with this pattern while bug testing, the syntax must remain how it is above, there MUST be spaces between if-expressions (I believe this is due to a bug in the <code>StringTokenizer</code> class)</p>
     * <p>Apart from that, enjoy :)</p>
     *
     * @param pattern The pattern to be compiled and searched for
     * @return the instructions defined to be returned in the pattern
     * @throws PatternFormatException if there is an error in your pattern
     */
    public List<Instruction> findInstructions(String pattern) throws PatternFormatException {
        pattern = pattern.toLowerCase();
        // Check pattern for validity
        // First check if there are any [ or ], if not then return null
        if (pattern.indexOf('[') < 0 && pattern.indexOf(']') < 0)
            return null;

        // The rest of the checking is done while compiling the pattern in an odd linked structure
        ArrayList<LinkedNode> tokens = new ArrayList<LinkedNode>();
        StringTokenizer at = new StringTokenizer(pattern, "()| ", true);
        while (at.hasMoreTokens()) {
            String token = at.nextToken();
            if (token.equals(" ")) {
            } else if (token.equals("(")) {
                int delta = 1;
                String subPattern = "";
                while (at.hasMoreTokens()) {
                    String nextToken = at.nextToken();
                    if (nextToken.equals("("))
                        delta++;
                    else if (nextToken.equals(")")) {
                        delta--;
                        if (delta == 0)
                            break;
                    }
                    subPattern += nextToken;
                }
                if (delta != 0)
                    throw new PatternFormatException("Expecting token: ')'");
                tokens.add(getSubs(subPattern));
            } else if (token.equals(")")) {
                throw new PatternFormatException("Unexpected token: ')'");
            } else if (token.equals("|"))
                throw new PatternFormatException("Unexpected token: '|'");
            else if (!token.matches("[\\w_]+"))
                throw new PatternFormatException("Unexpected token: '" + token + "'");
            else
                tokens.add(new LinkedNode(token));
        }

        LinkedNode[] ll = new LinkedNode[tokens.size()];
        ll = tokens.toArray(ll);
        LinkedList<Instruction> found = new LinkedList<>();
        boolean valid;
        int idx = 0;
        for (Instruction i : code) {
            if (matches(i, ll[idx])) {
                found.add(i);
                idx += 1;
                valid = true;
            } else {
                idx = 0;
                valid = false;
            }
            if (!valid)
                found.clear();
            else if (idx >= ll.length)
                return found;
        }
        return null;
    }

    private static boolean matches(Instruction i, LinkedNode pattern) {
        if (i.toString().startsWith(pattern.value.replace("[", "").replace("]", "")))
            return true;
        for (LinkedNode child : pattern.equals) {
            if (matches(i, child))
                return true;
        }
        return false;
    }

    private static LinkedNode getSubs(String pattern) throws PatternFormatException {
        boolean rOr = false;
        LinkedNode lns = new LinkedNode(null);
        StringTokenizer at = new StringTokenizer(pattern, "() ", true);
        while (at.hasMoreTokens()) {
            String token = at.nextToken();
            if (token.equals(" ")) {
            } else if (token.equals("(")) {
                int delta = 1;
                String subPattern = "";
                while (at.hasMoreTokens()) {
                    String nextToken = at.nextToken();
                    if (nextToken.equals("("))
                        delta++;
                    else if (nextToken.equals(")")) {
                        delta--;
                        if (delta == 0)
                            break;
                    }
                    subPattern += nextToken;
                }
                if (delta != 0)
                    throw new PatternFormatException("Expecting token: ')'");
                lns.addEqual(getSubs(subPattern));
            } else if (token.equals(")")) {
                throw new PatternFormatException("Unexpected token: ')'");
            } else if (token.equals("|")) {
                if (!rOr)
                    throw new PatternFormatException("Unexpected token: '|'");
                else
                    rOr = false;
            } else if (!token.matches("[\\w_]+"))
                throw new PatternFormatException("Unexpected token: '" + token + "'");
            else if (rOr)
                throw new PatternFormatException("Expecting token: '|");
            else if (lns.value == null) {
                lns.value = token;
                rOr = true;
            } else {
                lns.addEqual(new LinkedNode(token));
                rOr = true;
            }
        }
        return lns;
    }

    private static class LinkedNode {
        public String value;
        public ArrayList<LinkedNode> equals;

        public LinkedNode(String value) {
            this.value = value;
            this.equals = new ArrayList<LinkedNode>();
        }

        public void addEqual(LinkedNode e) {
            this.equals.add(e);
        }

        public String toString() {
            String val = value;
            for (LinkedNode e : equals)
                val += " | " + e.toString();
            return val;
        }
    }

    byte[] getBytes() throws IOException {
        fix();
        resetOffsets();
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        DataOutputStream dos = new DataOutputStream(baos);
        String[] posWidecode = new String[]{
                "ALOAD", "DLOAD", "FLOAD", "ILOAD", "LLOAD",
                "ASTORE", "DSTORE", "FSTORE", "ISTORE", "LSTORE",
                "IINC", "RET"
        };
        for (int v = 0; v < code.size(); v++) {
            Instruction i = code.get(v);
            try {
                // Todo: fix internal abstractions here, after checking if the instruction is wide
                for (String isname : posWidecode) {
                    if (Class.forName("org.newbiehacker.neeball." + isname).isInstance(i)) {
                        writePossibleWide(i, dos);
                    }
                }
                String name = i.getClass().getName();
                name = name.substring(name.lastIndexOf('.') + 1);
                if (i instanceof LoadInstruction) {
                    int index = ((LoadInstruction) i).index;
                    if (index <= 3)
                        name = name + "_" + index;
                } else if (i instanceof StoreInstruction) {
                    int index = ((StoreInstruction) i).index;
                    if (index <= 3)
                        name = name + "_" + index;
                } else if (i instanceof JSR) {
                    int offset = ((JSR) i).branchoffset;
                    if (offset < -32768 || offset > 32767)
                        name += "_W";
                } else if (i instanceof LDC) {
                    LDC l = (LDC) i;
                    if (l.c.isLong())
                        name += "2_W";
                    else if (l.index > 255)
                        name += "_W";
                }
                dos.write(Constants.class.getDeclaredField(name).getInt(null));
            } catch (Exception e) {
                e.printStackTrace();
                System.err.println("Invalid instruction!: " + i.getClass().getName());
                System.exit(-1);
            }
            if (i instanceof ANEWARRAY) {
                ANEWARRAY ci = (ANEWARRAY) i;
                dos.writeShort(ci.type_index);
            } else if (i instanceof BIPUSH) {
                BIPUSH ci = (BIPUSH) i;
                dos.writeByte(ci.b);
            } else if (i instanceof CHECKCAST) {
                CHECKCAST ci = (CHECKCAST) i;
                dos.writeShort(ci.index);
            } else if (i instanceof GETFIELD) {
                GETFIELD ci = (GETFIELD) i;
                dos.writeShort(ci.field_index);
            } else if (i instanceof GETSTATIC) {
                GETSTATIC ci = (GETSTATIC) i;
                dos.writeShort(ci.field_index);
            } else if (i instanceof GOTO) {
                GOTO ci = (GOTO) i;
                if (ci.branchoffset >= -32768 && ci.branchoffset <= 32767)
                    dos.writeShort(ci.branchoffset);
                else
                    dos.writeInt(ci.branchoffset);
            } else if (i instanceof IF_ACMPEQ) {
                IF_ACMPEQ ci = (IF_ACMPEQ) i;
                dos.writeShort(ci.branchoffset);
            } else if (i instanceof IF_ACMPNE) {
                IF_ACMPNE ci = (IF_ACMPNE) i;
                dos.writeShort(ci.branchoffset);
            } else if (i instanceof IF_ICMPEQ) {
                IF_ICMPEQ ci = (IF_ICMPEQ) i;
                dos.writeShort(ci.branchoffset);
            } else if (i instanceof IF_ICMPNE) {
                IF_ICMPNE ci = (IF_ICMPNE) i;
                dos.writeShort(ci.branchoffset);
            } else if (i instanceof IF_ICMPLT) {
                IF_ICMPLT ci = (IF_ICMPLT) i;
                dos.writeShort(ci.branchoffset);
            } else if (i instanceof IF_ICMPGE) {
                IF_ICMPGE ci = (IF_ICMPGE) i;
                dos.writeShort(ci.branchoffset);
            } else if (i instanceof IF_ICMPGT) {
                IF_ICMPGT ci = (IF_ICMPGT) i;
                dos.writeShort(ci.branchoffset);
            } else if (i instanceof IF_ICMPLE) {
                IF_ICMPLE ci = (IF_ICMPLE) i;
                dos.writeShort(ci.branchoffset);
            } else if (i instanceof IFEQ) {
                IFEQ ci = (IFEQ) i;
                dos.writeShort(ci.branchoffset);
            } else if (i instanceof IFNE) {
                IFNE ci = (IFNE) i;
                dos.writeShort(ci.branchoffset);
            } else if (i instanceof IFLT) {
                IFLT ci = (IFLT) i;
                dos.writeShort(ci.branchoffset);
            } else if (i instanceof IFGE) {
                IFGE ci = (IFGE) i;
                dos.writeShort(ci.branchoffset);
            } else if (i instanceof IFGT) {
                IFGT ci = (IFGT) i;
                dos.writeShort(ci.branchoffset);
            } else if (i instanceof IFLE) {
                IFLE ci = (IFLE) i;
                dos.writeShort(ci.branchoffset);
            } else if (i instanceof IFNONNULL) {
                IFNONNULL ci = (IFNONNULL) i;
                dos.writeShort(ci.branchoffset);
            } else if (i instanceof IFNULL) {
                IFNULL ci = (IFNULL) i;
                dos.writeShort(ci.branchoffset);
            } else if (i instanceof IINC) {
                IINC ci = (IINC) i;
                if (ci.index > 255 || ci.increment < -128 || ci.increment > 127) {
                    dos.writeShort(ci.index);
                    dos.writeShort(ci.increment);
                } else {
                    dos.writeByte(ci.index);
                    dos.writeByte(ci.increment);
                }
            } else if (i instanceof INSTANCEOF) {
                INSTANCEOF ci = (INSTANCEOF) i;
                dos.writeShort(ci.index);
            } else if (i instanceof INVOKEINTERFACE) {
                INVOKEINTERFACE ci = (INVOKEINTERFACE) i;
                dos.writeShort(ci.index);
                dos.writeByte(Util.getParamCount(ci.method.descriptor));
                dos.writeByte(0);
            } else if (i instanceof INVOKESPECIAL) {
                INVOKESPECIAL ci = (INVOKESPECIAL) i;
                dos.writeShort(ci.index);
            } else if (i instanceof INVOKESTATIC) {
                INVOKESTATIC ci = (INVOKESTATIC) i;
                dos.writeShort(ci.index);
            } else if (i instanceof INVOKEVIRTUAL) {
                INVOKEVIRTUAL ci = (INVOKEVIRTUAL) i;
                dos.writeShort(ci.index);
            } else if (i instanceof JSR) {
                JSR ci = (JSR) i;
                if (ci.branchoffset <= 65535)
                    dos.writeShort(ci.branchoffset);
                else
                    dos.writeInt(ci.branchoffset);
            } else if (i instanceof LDC) {
                LDC ci = (LDC) i;
                if (ci.index > 255 || ci.c.isLong())
                    dos.writeShort(ci.index);
                else
                    dos.writeByte(ci.index);
            } else if (i instanceof LoadInstruction) {
                LoadInstruction li = (LoadInstruction) i;
                if (li.index <= 3)
                    continue;
                if (li.index > 255)
                    dos.writeShort(li.index);
                else
                    dos.writeByte(li.index);
            } else if (i instanceof LOOKUPSWITCH) {
                LOOKUPSWITCH lus = (LOOKUPSWITCH) i;
                int index = getOffset(v);
                int padding = getPadding(index);
                for (int i1 = 0; i1 < padding; i1++) {
                    dos.writeByte(0);
                }
                dos.writeInt(lus.branchoffset);
                dos.writeInt(lus.match_pair_offsets.size());
                for (Integer key : lus.match_pair_offsets.keySet()) {
                    dos.writeInt(key);
                    dos.writeInt(lus.match_pair_offsets.get(key));
                }
            } else if (i instanceof MULTIANEWARRAY) {
                MULTIANEWARRAY ci = (MULTIANEWARRAY) i;
                dos.writeShort(ci.index);
                dos.writeByte(ci.dimensions);
            } else if (i instanceof NEW) {
                NEW ci = (NEW) i;
                dos.writeShort(ci.index);
            } else if (i instanceof NEWARRAY) {
                NEWARRAY ci = (NEWARRAY) i;
                dos.writeByte(ci.type);
            } else if (i instanceof PUTFIELD) {
                PUTFIELD ci = (PUTFIELD) i;
                dos.writeShort(ci.index);
            } else if (i instanceof PUTSTATIC) {
                PUTSTATIC ci = (PUTSTATIC) i;
                dos.writeShort(ci.index);
            } else if (i instanceof RET) {
                RET ci = (RET) i;
                if (ci.index > 255)
                    dos.writeShort(ci.index);
                else
                    dos.writeByte(ci.index);
            } else if (i instanceof SIPUSH) {
                SIPUSH ci = (SIPUSH) i;
                dos.writeShort(ci.s);
            } else if (i instanceof StoreInstruction) {
                StoreInstruction si = (StoreInstruction) i;
                if (si.index <= 3)
                    continue;
                if (si.index > 255)
                    dos.writeShort(si.index);
                else
                    dos.writeByte(si.index);
            } else if (i instanceof TABLESWITCH) {
                TABLESWITCH ts = (TABLESWITCH) i;
                int index = getOffset(v);
                int padding = getPadding(index);
                for (int i1 = 0; i1 < padding; i1++) {
                    dos.writeByte(0);
                }
                dos.writeInt(ts.branchoffset);
                NavigableSet<Integer> ns = ts.match_pair_offsets.navigableKeySet();
                dos.writeInt(ns.first());
                dos.writeInt(ns.last());
                for (Integer i1 : ts.match_pair_offsets.values())
                    dos.writeInt(i1);
            }
        }
        dos.close();
        baos.close();
        return baos.toByteArray();
    }

    private void writePossibleWide(Instruction i, DataOutputStream dos) throws IOException {
        if (i instanceof LoadInstruction && ((LoadInstruction) i).index > 255)
            dos.writeByte(0xc4);
        else if (i instanceof StoreInstruction && ((StoreInstruction) i).index > 255)
            dos.writeByte(0xc4);
        else if (i instanceof RET && ((RET) i).index > 255)
            dos.writeByte(0xc4);
        else if (i instanceof IINC) {
            IINC ci = (IINC) i;
            if (ci.index > 255 || ci.increment < -128 || ci.increment > 127) {
                dos.writeByte(0xc4);
            }
        }
    }

    public int compareTo(Method m) {
        if (m.is_static && !is_static)
            return 1;
        else if (!m.is_static && is_static)
            return -1;
        return name.compareTo(m.name) + descriptor.compareTo(m.descriptor);
    }

    public String toString() {
        return Util.getFriendlyMethodString(name, descriptor);
    }

    protected void finalize() throws Throwable {
        super.finalize();
        name = null;
        descriptor = null;
        code.clear();
        code = null;
        exception_table.clear();
        exception_table = null;
        thrown_exceptions_table.clear();
        thrown_exceptions_table = null;
        exception_index_table = null;
        signature = null;
    }
}